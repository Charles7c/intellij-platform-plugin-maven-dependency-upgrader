package top.charles7c.mavendependencyupgrader.service

import com.intellij.openapi.components.Service
import com.intellij.openapi.diagnostic.thisLogger
import com.intellij.util.io.HttpRequests
import top.charles7c.mavendependencyupgrader.model.DependencyInfo
import top.charles7c.mavendependencyupgrader.model.VulnerabilityInfo
import java.io.IOException

/**
 * 安全漏洞扫描服务，通过 Sonatype OSS Index API 查询已知漏洞
 *
 * OSS Index API 文档: https://ossindex.sonatype.org/rest
 * 免费使用，无需认证（每小时最多 128 次请求）
 */
@Service(Service.Level.APP)
class VulnerabilityService {

    private val logger = thisLogger()

    private val OSS_INDEX_API = "https://ossindex.sonatype.org/api/v3/component-report"

    // 每批最多发送 128 个坐标（OSS Index 限制）
    private val BATCH_SIZE = 128

    /**
     * 批量检查依赖漏洞
     *
     * @param dependencies 要扫描的依赖列表
     * @return Map，key 为 "groupId:artifactId"，value 为漏洞列表
     */
    fun checkVulnerabilities(dependencies: List<DependencyInfo>): Map<String, List<VulnerabilityInfo>> {
        val result = mutableMapOf<String, List<VulnerabilityInfo>>()

        dependencies.chunked(BATCH_SIZE).forEach { batch ->
            try {
                result.putAll(queryBatch(batch))
            } catch (e: IOException) {
                logger.info("OSS Index API unavailable (offline?): ${e.message}")
            } catch (e: Exception) {
                logger.warn("Error querying OSS Index: ${e.message}")
            }
        }

        return result
    }

    private fun queryBatch(batch: List<DependencyInfo>): Map<String, List<VulnerabilityInfo>> {
        val coordinates = batch.joinToString(",\n    ") { dep ->
            "\"pkg:maven/${dep.groupId}/${dep.artifactId}@${dep.currentVersion}\""
        }
        val requestBody = """{"coordinates": [$coordinates]}"""

        val responseText = HttpRequests.post(OSS_INDEX_API, "application/json")
            .connectTimeout(15_000)
            .readTimeout(30_000)
            .connect { request ->
                request.write(requestBody)
                request.readString()
            }

        return parseResponse(responseText)
    }

    /**
     * 解析 OSS Index 响应（使用栈式括号匹配，正确处理嵌套 JSON）
     *
     * 响应格式（顶层数组）：
     * [{"coordinates":"pkg:maven/g/a@v","vulnerabilities":[{...},...]}]
     */
    private fun parseResponse(json: String): Map<String, List<VulnerabilityInfo>> {
        val result = mutableMapOf<String, List<VulnerabilityInfo>>()

        // 用括号匹配法切分顶层对象
        for (componentJson in splitTopLevelObjects(json)) {
            val coordinates = extractString(componentJson, "coordinates") ?: continue
            val key = parsePurlToKey(coordinates) ?: continue

            val vulnsArrayJson = extractBracketedValue(componentJson, "vulnerabilities", '[', ']')
                ?: continue

            val vulns = parseVulnerabilities(vulnsArrayJson)
            if (vulns.isNotEmpty()) {
                result[key] = vulns
            }
        }

        return result
    }

    /**
     * 从 PURL 格式提取 groupId:artifactId 键
     * pkg:maven/org.springframework/spring-core@5.3.0 -> org.springframework:spring-core
     */
    private fun parsePurlToKey(purl: String): String? {
        val match = Regex("""pkg:maven/([^/]+)/([^@]+)@""").find(purl) ?: return null
        return "${match.groupValues[1]}:${match.groupValues[2]}"
    }

    private fun parseVulnerabilities(vulnsArrayJson: String): List<VulnerabilityInfo> {
        val vulns = mutableListOf<VulnerabilityInfo>()

        for (vulnJson in splitTopLevelObjects(vulnsArrayJson)) {
            val id = extractString(vulnJson, "id") ?: continue
            val displayName = extractString(vulnJson, "displayName") ?: id
            val title = extractString(vulnJson, "title") ?: displayName
            val description = extractString(vulnJson, "description") ?: ""
            val cvssScore = extractDouble(vulnJson, "cvssScore")?.toFloat() ?: 0f
            val reference = extractString(vulnJson, "reference") ?: ""

            vulns.add(
                VulnerabilityInfo(
                    id = displayName.ifBlank { id },
                    title = title,
                    description = description,
                    severity = VulnerabilityInfo.Severity.fromCvssScore(cvssScore),
                    cvssScore = cvssScore,
                    reference = reference
                )
            )
        }

        return vulns.sortedByDescending { it.severity.priority }
    }

    /**
     * 用栈式括号匹配法，从字符串中提取所有顶层 {...} 对象
     */
    private fun splitTopLevelObjects(json: String): List<String> {
        val objects = mutableListOf<String>()
        var depth = 0
        var start = -1

        for (i in json.indices) {
            when {
                json[i] == '{' && !isInsideString(json, i) -> {
                    if (depth == 0) start = i
                    depth++
                }
                json[i] == '}' && !isInsideString(json, i) -> {
                    depth--
                    if (depth == 0 && start >= 0) {
                        objects.add(json.substring(start, i + 1))
                        start = -1
                    }
                }
            }
        }
        return objects
    }

    /**
     * 从 JSON 对象中提取指定 key 对应的括号内容（支持 [...] 或 {...}）
     */
    private fun extractBracketedValue(json: String, key: String, open: Char, close: Char): String? {
        val keyIndex = json.indexOf("\"$key\"") + "\"$key\"".length
        if (keyIndex < "\"$key\"".length) return null

        val colonIndex = json.indexOf(':', keyIndex)
        if (colonIndex < 0) return null

        var openIndex = -1
        for (i in (colonIndex + 1) until json.length) {
            if (json[i] == open) { openIndex = i; break }
        }
        if (openIndex < 0) return null

        var depth = 0
        for (i in openIndex until json.length) {
            when {
                json[i] == open && !isInsideString(json, i) -> depth++
                json[i] == close && !isInsideString(json, i) -> {
                    depth--
                    if (depth == 0) return json.substring(openIndex, i + 1)
                }
            }
        }
        return null
    }

    /**
     * 简单判断字符串中某个位置是否在双引号内（不处理转义边角情况）
     */
    private fun isInsideString(s: String, index: Int): Boolean {
        var count = 0
        var i = 0
        while (i < index) {
            if (s[i] == '"' && (i == 0 || s[i - 1] != '\\')) count++
            i++
        }
        return count % 2 == 1
    }

    private fun extractString(json: String, key: String): String? {
        return Regex(""""$key"\s*:\s*"((?:[^"\\]|\\.)*)"""").find(json)
            ?.groupValues?.getOrNull(1)
            ?.replace("\\\"", "\"")
            ?.replace("\\\\", "\\")
            ?.replace("\\n", "\n")
    }

    private fun extractDouble(json: String, key: String): Double? {
        return Regex(""""$key"\s*:\s*([\d.]+)""").find(json)?.groupValues?.getOrNull(1)?.toDoubleOrNull()
    }
}
